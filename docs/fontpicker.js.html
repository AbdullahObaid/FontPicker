<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: fontpicker.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: fontpicker.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as google from "./google-fonts.js";
import translations from "./translations.js";

let initialized = false;
const loadedFonts = {};

// default options
const options = {
    language: "en",
    variants: true, // currently not used
    recents: 3,
    localFontsUrl: "/fonts/",
    localFontsType: "woff",
    localFonts: {},
    googleFonts: google.fonts,
    defaultFont: "Open Sans",
};

let modal;
let openedPicker;
let selectedFont;

// data storage for favorites and recents
let data = JSON.parse(localStorage.getItem("font_picker_data")) ?? { fav: [], rec: [] };
const storeData = () => localStorage.setItem("font_picker_data", JSON.stringify(data));

// make favourites and recents the first items in the picker
const sortFonts = () => {
    [...data.fav, ...data.rec].forEach((font) => {
        const element = document.querySelector(`#fp__fonts > [data-family="${font}"]`);
        if(element) element.parentElement.prepend(element);
    });
};

// when a heart button is pressed, add or remove the font from the favourites
const onHeartClick = function(e) {
    const family = this.parentElement.dataset.family;
    const favourite = this.classList.toggle("fp__fav");

    if(favourite) {
        data.fav.push(family);
    } else {
        data.fav = data.fav.filter((f) => f !== family);
    }

    storeData();
    sortFonts();

    favourite &amp;&amp; this.parentElement.scrollIntoView({ block: "center" });
};

// create a heart button
const createHeart = () => {
    const button = document.createElement("span");
    button.className = "float-end fp__heart";
    button.setAttribute("role", "button");
    button.innerHTML = `&lt;svg xmlns="http://www.w3.org/2000/svg" stroke-width="2" viewBox="0 0 18 18">&lt;path d="M9 2.314 C13.438-2.248 24.534 5.735 9 16-6.534 5.736 4.562-2.248 9 2.314z" />&lt;/svg>`;
    button.addEventListener("click", onHeartClick);
    return button;
};

// select a font item from the picker
const selectFont = (font) => {
    if(selectedFont) {
        if(selectedFont === font) return; // already selected
        selectedFont.classList.remove("fp__selected");

        // remove heart if it is not a favourite
        const heart = selectedFont.querySelector(".fp__heart");
        if(!heart.classList.contains("fp__fav")) heart.remove();
    }

    // make selected and add a heart button
    font.classList.add("fp__selected");
    if(!font.querySelector(".fp__heart")) {
        font.appendChild(createHeart());
    }

    selectedFont = font;
};

// open a font picker from its input
const openPicker = (input) => {
    if(!modal) createModal();
    openedPicker = input;

    // set the input value as the selected font
    const family = input.value || options.defaultFont;
    selectFont(document.querySelector(`#fp__fonts > [data-family="${family}"]`));

    sortFonts();
    modal.show();
};

// set the value of the input element
const setPicker = (input, value, fire = false) => {
    loadFont(value);

    input.value = value;
    input.style.fontFamily = value;

    // add to recents
    data.rec = data.rec.filter((f) => f !== value);
    while(data.rec.length >= options.recents) data.rec.shift();
    data.rec.push(value);
    storeData();

    fire &amp;&amp; input.dispatchEvent(new Event("input"));
};

// when search input changes
const onSearchInput = (e) => {
    const filter = e.target.value.toLowerCase().trim();
    const fonts = document.querySelectorAll("#fp__fonts > div");
    fonts.forEach((font) => {
        const name = font.dataset.family.toLowerCase();
        font.classList.toggle("hide-s", !name.includes(filter));
    });
};

// when a font category badge is clicked
const onBadgeClick = (e) => {
    const active = e.target.classList.toggle("btn-primary");
    e.target.classList.toggle("btn-secondary", !active);

    const category = e.target.innerText;
    const fonts = document.querySelectorAll("#fp__fonts > div");
    fonts.forEach((font) => {
        if(font.dataset.category == category) {
            font.classList.toggle("hide-c", !active);
        }
    });
};

// when the language select changes
const onLangChange = (e) => {
    const lang = e.target.value;
    const fonts = document.querySelectorAll("#fp__fonts > div");

    fonts.forEach((font) => {
        const fontLang = font.dataset.subsets.split(",");
        const hide = !fontLang.includes(lang) &amp;&amp; lang !== "all";
        font.classList.toggle("hide-l", hide);
    });
};

// when a font item is clicked and double clicked
const onFontClick = function(e) {
    selectFont(this);
};

const onFontDblClick = function(e) {
    setPicker(openedPicker, this.dataset.family, true);
    modal.hide();
};

// create the modal
const createModal = () => {
    // insert the modal HTML and a small stylesheet into the document
    document.head.insertAdjacentHTML("beforeend", `&lt;style>.hide-s, .hide-c, .hide-l { display: none; } #fp__preview { white-space: nowrap; text-overflow: ellipsis; overflow: hidden; } .fp__font-item { color: var(--bs-dark); } .fp__font-item:hover { background: var(--bs-gray-300); } .fp__font-item.fp__selected { color: var(--bs-light); background: var(--bs-primary); } .fp__heart>svg { fill: none; stroke: var(--bs-light); height: 1em; } .fp__heart:hover>svg { fill: var(--bs-light); } .fp__heart.fp__fav>svg { stroke: var(--bs-danger); fill: var(--bs-danger); }&lt;/style>`);
    document.body.insertAdjacentHTML("beforeend", `&lt;div class="modal fade" id="fp__modal" tabindex="-1">&lt;div class="modal-dialog modal-dialog-scrollable">&lt;div class="modal-content">&lt;div class="modal-header">&lt;h5 class="modal-title" id="fp__title">&lt;/h5>&lt;button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close">&lt;/button>&lt;/div>&lt;div class="row g-2 py-2 px-3 border border-bottom">&lt;div class="col-sm-6">&lt;input class="form-control" id="fp__search">&lt;/div>&lt;div class="col-sm-6"> &lt;select class="form-select" id="fp__languages">&lt;/select>&lt;/div>&lt;div class="col-12 d-flex flex-wrap gap-2 justify-content-center" id="fp__categories">&lt;/div>&lt;div class="col-12 text-center fs-5" id="fp__preview" contenteditable spellcheck="false">&lt;/div>&lt;/div>&lt;div class="modal-body pt-2" id="fp__fonts">&lt;/div>&lt;div class="modal-footer">&lt;button type="button" class="btn btn-secondary" id="fp__cancel">&lt;/button>&lt;button type="button" class="btn btn-primary" id="fp__pick">&lt;/button>&lt;/div>&lt;/div>&lt;/div>&lt;/div>`);

    // keep references to often used elements
    const fpModal = document.getElementById("fp__modal");
    const fpLanguages = document.getElementById("fp__languages");
    const fpCategories = document.getElementById("fp__categories");
    const fpFonts = document.getElementById("fp__fonts");
    const fpPick = document.getElementById("fp__pick");
    const fpCancel = document.getElementById("fp__cancel");
    const fpSearch = document.getElementById("fp__search");

    // translate title and preview text
    document.getElementById("fp__title").innerText = translations[options.language].selectFont;
    document.getElementById("fp__preview").innerText = translations[options.language].sampleText;

    // populate language select element
    const languageOptions = [
        ["all", translations[options.language].allLangs],
        ...Object.entries(google.languages),
    ];

    for (const [value, text] of languageOptions) {
        const option = document.createElement("option");
        option.value = value;
        option.innerText = text;
        fpLanguages.appendChild(option);
    }

    fpLanguages.addEventListener("change", onLangChange);

    // create category filter badges
    for (const category of google.categories) {
        const badge = document.createElement("button");
        badge.className = "badge rounded-pill btn btn-primary";
        badge.innerText = category;
        fpCategories.appendChild(badge);

        badge.addEventListener("click", onBadgeClick);
    }

    // make input searchable
    fpSearch.placeholder = translations[options.language].search;
    fpSearch.addEventListener("input", onSearchInput);

    // when fonts are scrolled into view, load them
    const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
            if (entry.intersectionRatio > 0) {
                const fontItem = entry.target;
                const family = fontItem.dataset.family;

                loadFont(family);
                observer.unobserve(fontItem);
            }
        });
    });

    // populate font list with all fonts
    const fontList = { ...options.localFonts || {}, ...options.googleFonts || {} };

    for (const [family, font] of Object.entries(fontList)) {
        const fontItem = document.createElement("div");
        fontItem.className = "px-3 py-1 my-1 fp__font-item rounded-pill user-select-none";
        fontItem.setAttribute("role", "button");

        const fontName = document.createElement("span");
        fontName.className = "fs-6";
        fontName.innerText = family;
        fontName.style.fontFamily = family;

        fontItem.appendChild(fontName);
        fpFonts.appendChild(fontItem);

        fontItem.dataset.family = family;
        fontItem.dataset.category = font.category;
        fontItem.dataset.subsets = font.subsets ?? "";

        // if favourite, add heart button
        if (data.fav.includes(family)) {
            const heartButton = createHeart();
            heartButton.classList.add("fp__fav");
            fontItem.appendChild(heartButton);
        }

        observer.observe(fontItem);
        fontItem.addEventListener("click", onFontClick);
        fontItem.addEventListener("dblclick", onFontDblClick);
    }

    // make the pick button clickable
    fpPick.innerText = translations[options.language].select;
    fpPick.addEventListener("click", () => {
        setPicker(openedPicker, selectedFont.dataset.family, true);
        modal.hide();
    });

    // make the cancel button clickable
    fpCancel.innerText = translations[options.language].cancel;
    fpCancel.addEventListener("click", () => {
        modal.hide();
    });

    // on open, scroll to selected font
    fpModal.addEventListener("shown.bs.modal", () => {
        selectedFont.scrollIntoView({ block: "center" });
    });

    modal = new bootstrap.Modal(fpModal);
};

/**
 * @function loadFont
 * @description Load a font by name
 * @memberof FontPicker
 * @param {string} name font family
 * @returns {Promise} promise that resolves when font is loaded
 */
const loadFont = (name) => {
    // return existing promise
    if (loadedFonts.hasOwnProperty(name)) {
        return loadedFonts[name];
    }

    let promise;
    const googleFont = options.googleFonts[name];
    if (googleFont) {
        // Load Google font
        const family = `${encodeURIComponent(name)}:${googleFont.variants}&amp;display=swap`;
        const url = "https://fonts.googleapis.com/css?family=" + family;
        const link = document.createElement("link");
        link.href = url;
        link.rel = "stylesheet";
        link.type = "text/css";
        document.head.appendChild(link);

        // set promise that waits for font to load
        promise = new Promise((resolve) => {
            link.addEventListener("load", () => {
                const shorthand = `1em "${name}"`;
                document.fonts.load(shorthand).then(resolve);
            });
        });
    } else {
        // Load local font
        const fontUrl = `${options.localFontsUrl}${font}.${options.localFontsType}`;
        const fontFace = new FontFace(font, `url(${fontUrl})`);

        // add font and set promise that waits for font to load
        promise = document.fonts.add(fontFace).load(font);
    }

    loadedFonts[name] = promise;
    return promise;
};

/**
 * @function initialize
 * @description Initialize the font picker
 * @memberof FontPicker
 * @param {Object} _options
 * @param {string} _options.language font picker language
 * @param {boolean} _options.variants use font variants?
 * @param {number} _options.recents number of recent fonts to show
 * @param {string} _options.localFontsUrl url to local fonts
 * @param {string} _options.localFontsType local font type extension
 * @param {Object?} _options.localFonts local fonts object
 * @param {Object?} _options.googleFonts google fonts object
 * @param {string} _options.defaultFont default font
 */

const initialize = (_options) => {
    // ensure the font picker is not initialized twice
    if(initialized) {
        throw new TypeError("Font picker has already been initialized.");
    }

    Object.assign(options, _options);
    initialized = true;
};

/**
 * @function create
 * @description Create a font picker and return it
 * @memberof FontPicker
 * @returns {HTMLInputElement} font picker
 */

const create = () => {
    const input = document.createElement("input");
    input.type = "text";
    return attach(input);
};

/**
 * @function attach
 * @description Attach a font picker to an input element
 * @memberof FontPicker
 * @param {HTMLInputElement} input
 * @returns {HTMLInputElement} font picker
 */

const attach = (input) => {
    if (!initialized) {
        throw new TypeError("Font picker has not been initialized yet.");
    }

    input.classList.add("form-select");
    input.setAttribute("readonly", "readonly");
    input.setAttribute("role", "button");

    input.open = () => openPicker(input);
    input.set = (font, fire) => setPicker(input, font, fire);
    input.addEventListener("click", input.open);

    return input;
};

/**
 * @namespace FontPicker
 */
const FontPicker = {
    loadFont,
    initialize,
    create,
    attach,
};

export default FontPicker;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="FontPicker.html">FontPicker</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Wed Feb 15 2023 11:33:40 GMT+0100 (Central European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
